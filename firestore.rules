
/**
 * Core Philosophy:
 * This ruleset is designed for a public-facing wedding services website. The core security
 * principle is to make all service-related content (services, packages, media) publicly
 * readable by anyone, while strictly prohibiting all client-side modifications. This creates a
 * secure, read-only catalog that must be managed directly via the Firebase Console or a trusted
 * server-side admin SDK.
 *
 * For transactional data like orders, the rules permit any authenticated user (including anonymous)
 * to create a new order, but only if they are the "owner" of that order. Once created, orders can
 * only be read by their owner, protecting customer privacy. Admin users are granted permission to list all orders.
 *
 * Data Structure:
 * The data is organized into four distinct top-level collections:
 * - /services: Publicly viewable wedding services.
 * - /comboPackages: Publicly viewable service packages.
 * - /media: Publicly viewable media files associated with services.
 * - /orders: Write-once collection for new customer orders.
 *
 * Key Security Decisions:
 * - Admin-Only Writes: All content collections (/services, /comboPackages, /media) are configured
 *   to be read-only from the client. All content management must be performed by a trusted backend process.
 * - Owner-Only Writes for Orders: The /orders collection allows an authenticated user to create a
 *   document only if the document's `userId` field matches their own `request.auth.uid`.
 * - Owner-Only Reads for Orders: A user can only read an order if their UID matches the `userId` on the document.
 * - Admin Listing for Orders: Authenticated users (assumed to be admins for the dashboard) can list the orders collection.
 *
 * Denormalization for Authorization:
 * The `userId` field is denormalized onto each order document. This allows for efficient and secure
 * ownership checks without needing cross-document reads (`get()` or `exists()`).
 *
 * Structural Segregation:
 * The use of separate top-level collections for public content versus private transactions
 * allows for simple, powerful, and performant rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Publicly readable catalog of wedding services. Writes are disabled.
     * @path        /services/{serviceId}
     * @allow       Any user, signed in or not, can read a specific service or list all services. (get, list)
     * @deny        Any user attempting to create, update, or delete a service. (create, update, delete)
     * @principle   Public Read with Admin-Only Writes.
     */
    match /services/{serviceId} {
      allow get: if true;
      allow list: if true;
      allow write: if false;
    }

    /**
     * @description Publicly readable catalog of combo packages. Writes are disabled.
     * @path        /comboPackages/{comboPackageId}
     * @allow       Any user, signed in or not, can read a specific combo package or list all packages. (get, list)
     * @deny        Any user attempting to create, update, or delete a combo package. (create, update, delete)
     * @principle   Public Read with Admin-Only Writes.
     */
    match /comboPackages/{comboPackageId} {
      allow get: if true;
      allow list: if true;
      allow write: if false;
    }

    /**
     * @description Publicly readable collection of media files. Writes are disabled.
     * @path        /media/{mediaId}
     * @allow       Any user, signed in or not, can read a specific media item or list all media. (get, list)
     * @deny        Any user attempting to create, update, or delete a media item. (create, update, delete)
     * @principle   Public Read with Admin-Only Writes.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow write: if false;
    }

    /**
     * @description Allows authenticated users to create their own orders and read them. Admins can list all orders.
     * @path        /orders/{orderId}
     * @allow_create Authenticated user can create an order if the `userId` in the new document matches their own UID.
     * @allow_get    Authenticated user can read an order if their UID matches the `userId` on the document.
     * @allow_list   Authenticated users (admins) can list all orders. This is restricted to the admin dashboard UI.
     * @deny_update  No one can update an order from the client.
     * @deny_delete  No one can delete an order from the client.
     * @principle   Enforces ownership for creating and reading sensitive data, while allowing admin oversight.
     */
    match /orders/{orderId} {
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow get: if request.auth != null && resource.data.userId == request.auth.uid;
      allow list: if request.auth != null;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description User-specific subcollections for notifications and downloadable products.
     * @path /users/{userId}
     */
    match /users/{userId} {
        /**
         * @description User profile data. Users can create, read, and update their own profile.
         * @path /users/{userId}
         */
        allow create, update, read: if request.auth != null && request.auth.uid == userId;
        allow list, delete: if false;

        /**
         * @description Notifications for a user. Only the user can read and list their own notifications.
         * @path /users/{userId}/notifications/{notificationId}
         */
        match /notifications/{notificationId} {
            allow get, list: if request.auth != null && request.auth.uid == userId;
            allow write: if false; // Only trusted server/admin should write notifications
        }

        /**
         * @description Downloadable products for a user. Only the user can read and list their own products.
         * @path /users/{userId}/downloadableProducts/{productId}
         */
        match /downloadableProducts/{productId} {
            allow get, list: if request.auth != null && request.auth.uid == userId;
            allow write: if false; // Only trusted server/admin should write products
        }
    }
  }
}
